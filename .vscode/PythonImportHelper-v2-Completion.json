[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "retry_call",
        "importPath": "retry.api",
        "description": "retry.api",
        "isExtraImport": true,
        "detail": "retry.api",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "retry.api",
        "description": "retry.api",
        "isExtraImport": true,
        "detail": "retry.api",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "retry",
        "kind": 2,
        "importPath": "retry.api",
        "description": "retry.api",
        "peekOfCode": "def retry(exceptions=Exception, tries=-1, delay=0, max_delay=None, backoff=1, jitter=0, logger=logging_logger,\n          callback_between=None,\n          callback_between_args=[],\n          callback_between_kwargs={}):\n    \"\"\"Returns a retry decorator.\n    :param exceptions: an exception or a tuple of exceptions to catch. default: Exception.\n    :param tries: the maximum number of attempts. default: -1 (infinite).\n    :param delay: initial delay between attempts. default: 0.\n    :param max_delay: the maximum value of delay. default: None (no limit).\n    :param backoff: multiplier applied to delay between attempts. default: 1 (no backoff).",
        "detail": "retry.api",
        "documentation": {}
    },
    {
        "label": "retry_call",
        "kind": 2,
        "importPath": "retry.api",
        "description": "retry.api",
        "peekOfCode": "def retry_call(f, fargs=None, fkwargs=None, exceptions=Exception, tries=-1, delay=0, max_delay=None, backoff=1,\n               jitter=0,\n               logger=logging_logger,\n               callback_between=None,\n               callback_between_args=None,\n               callback_between_kwargs=None):\n    \"\"\"\n    Calls a function and re-executes it if it failed.\n    :param f: the function to execute.\n    :param fargs: the positional arguments of the function to execute.",
        "detail": "retry.api",
        "documentation": {}
    },
    {
        "label": "logging_logger",
        "kind": 5,
        "importPath": "retry.api",
        "description": "retry.api",
        "peekOfCode": "logging_logger = logging.getLogger(__name__)\ndef __retry_internal(f, exceptions=Exception, tries=-1, delay=0, max_delay=None, backoff=1, jitter=0,\n                     logger=logging_logger, callback_between=None):\n    \"\"\"\n    Executes a function and retries it if it failed.\n    :param f: the function to execute.\n    :param exceptions: an exception or a tuple of exceptions to catch. default: Exception.\n    :param tries: the maximum number of attempts. default: -1 (infinite).\n    :param delay: initial delay between attempts. default: 0.\n    :param max_delay: the maximum value of delay. default: None (no limit).",
        "detail": "retry.api",
        "documentation": {}
    },
    {
        "label": "test_retry",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_retry(monkeypatch):\n    mock_sleep_time = [0]\n    def mock_sleep(seconds):\n        mock_sleep_time[0] += seconds\n    monkeypatch.setattr(time, 'sleep', mock_sleep)\n    hit = [0]\n    tries = 5\n    delay = 1\n    backoff = 2\n    @retry(tries=tries, delay=delay, backoff=backoff)",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_tries_inf",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_tries_inf():\n    hit = [0]\n    target = 10\n    @retry(tries=float('inf'))\n    def f():\n        hit[0] += 1\n        if hit[0] == target:\n            return target\n        else:\n            raise ValueError",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_tries_minus1",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_tries_minus1():\n    hit = [0]\n    target = 10\n    @retry(tries=-1)\n    def f():\n        hit[0] += 1\n        if hit[0] == target:\n            return target\n        else:\n            raise ValueError",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_max_delay",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_max_delay(monkeypatch):\n    mock_sleep_time = [0]\n    def mock_sleep(seconds):\n        mock_sleep_time[0] += seconds\n    monkeypatch.setattr(time, 'sleep', mock_sleep)\n    hit = [0]\n    tries = 5\n    delay = 1\n    backoff = 2\n    max_delay = delay  # Never increase delay",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_fixed_jitter",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_fixed_jitter(monkeypatch):\n    mock_sleep_time = [0]\n    def mock_sleep(seconds):\n        mock_sleep_time[0] += seconds\n    monkeypatch.setattr(time, 'sleep', mock_sleep)\n    hit = [0]\n    tries = 10\n    jitter = 1\n    @retry(tries=tries, jitter=jitter)\n    def f():",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_retry_call",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_retry_call():\n    f_mock = MagicMock(side_effect=RuntimeError)\n    tries = 2\n    try:\n        retry_call(f_mock, exceptions=RuntimeError, tries=tries)\n    except RuntimeError:\n        pass\n    assert f_mock.call_count == tries\ndef test_retry_call_2():\n    side_effect = [RuntimeError, RuntimeError, 3]",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_retry_call_2",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_retry_call_2():\n    side_effect = [RuntimeError, RuntimeError, 3]\n    f_mock = MagicMock(side_effect=side_effect)\n    tries = 5\n    result = None\n    try:\n        result = retry_call(f_mock, exceptions=RuntimeError, tries=tries)\n    except RuntimeError:\n        pass\n    assert result == 3",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_retry_call_with_args",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_retry_call_with_args():\n    def f(value=0):\n        if value < 0:\n            return value\n        else:\n            raise RuntimeError\n    return_value = -1\n    result = None\n    f_mock = MagicMock(spec=f, return_value=return_value)\n    try:",
        "detail": "tests.test_retry",
        "documentation": {}
    },
    {
        "label": "test_retry_call_with_kwargs",
        "kind": 2,
        "importPath": "tests.test_retry",
        "description": "tests.test_retry",
        "peekOfCode": "def test_retry_call_with_kwargs():\n    def f(value=0):\n        if value < 0:\n            return value\n        else:\n            raise RuntimeError\n    kwargs = {'value': -1}\n    result = None\n    f_mock = MagicMock(spec=f, return_value=kwargs['value'])\n    try:",
        "detail": "tests.test_retry",
        "documentation": {}
    }
]